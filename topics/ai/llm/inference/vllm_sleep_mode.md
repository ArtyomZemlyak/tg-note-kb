# Режим сна vLLM (vLLM Sleep Mode)

## Описание

Режим сна vLLM - это новая функция, представленная в vLLM 0.11, которая позволяет эффективно переключаться между моделями "на горячую". Модель может быть "успокоена" и позже быстро "разбужена", без необходимости полной перезагрузки процесса.

## Контекст проблемы

Традиционно при многофункциональном обслуживании LLM возникают следующие проблемы:
1. Удержание обеих моделей в памяти требует в 2 раза больше GPU-памяти (дорого и часто невозможно)
2. Перезагрузка моделей по требованию занимает 30-100+ секунд на переключение (медленно и неэффективно)

Режим сна vLLM предлагает третий путь: модели впадают в спячку за секунды и просыпаются быстро, обеспечивая эффективность загрузки по требованию при скорости постоянного обслуживания.

## Уровни сна

vLLM предлагает два уровня сна для разных потребностей:

### Уровень 1
- Выгружает веса модели в оперативную память CPU, отбрасывает кэш KV
- Обеспечивает самые быстрые времена пробуждения (~0.1-6с)
- Требует достаточной оперативной памяти CPU для хранения весов модели
- Лучше всего подходит для систем с достаточной памятью CPU и частого переключения между моделями

### Уровень 2
- Полностью отбрасывает веса модели и кэш KV, сохраняет только буферы (масштабирование rope и т.д.)
- Более медленные времена пробуждения (~0.8-2.6с для небольших моделей) из-за перезагрузки весов с диска
- Минимальное использование оперативной памяти CPU - только небольшие буферы сохраняются
- Лучше всего подходит для систем с ограниченной памятью CPU или при управлении несколькими моделями, которые не помещаются в память одновременно

## Преимущества

1. **Значительное ускорение переключения моделей**: 18-200x быстрее по сравнению с полной перезагрузкой
2. **Улучшенная производительность инференса**: 61-88% быстрее после пробуждения за счет сохраненной инфраструктуры
3. **Экономия ресурсов**: Позволяет переключаться между моделями, которые не помещаются одновременно в GPU-память
4. **Сохранение разогретой инфраструктуры**: Сохраняются CUDA-графы, JIT-компиляция, распределитель памяти и другие компоненты

## Технические детали

Режим сна сохраняет инфраструктуру CUDA и другие компоненты процесса, избегая дорогостоящей повторной инициализации:

- Распределитель памяти CUDA (CuMemAllocator) - сохраняется
- Графы CUDA - сохраняются
- Состояние процесса (Python, контекст CUDA) - сохраняется
- Кэш JIT-компиляции ядер GPU (DeepGEMM, FlashInfer, TorchInductor) - сохраняется

## Использование

Для включения режима сна при запуске vLLM:

```bash
vllm serve microsoft/Phi-3-vision-128k-instruct --enable-sleep-mode --port 8001
```

Команды API:
- `/sleep?level=2` - отправить модель в спячку
- `/wake_up` - пробудить модель
- `/collective_rpc` - для перезагрузки весов (только уровень 2)
- `/reset_prefix_cache` - сбросить предварительный кэш (только уровень 2)

## Производительность

- Уровень 1: на 68% быстрее режима без сна, но требует значительной оперативной памяти CPU
- Уровень 2: на 65% быстрее режима без сна с минимальными требованиями к оперативной памяти
- Оба уровня сна обеспечивают огромное улучшение по сравнению с традиционными подходами

## Связи с другими темами

- [[vllm_summary.md]] - Основной обзор vLLM
- [[gpu_memory_management.md]] - Управление GPU-памятью в системах LLM
- [[distributed_inference.md]] - Распределенные подходы к инференсу