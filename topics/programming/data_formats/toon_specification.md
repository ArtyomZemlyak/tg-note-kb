# Спецификация формата TOON

## Общая информация

**Текущая версия спецификации:** 1.3  
**Дата публикации:** 2025-10-31  
**Статус:** Рабочий черновик  
**Автор:** Johann Schopplich

## Цель формата

Token-Oriented Object Notation (TOON) - это формат сериализации данных, оптимизированный для контекста Large Language Model (LLM), позволяющий достичь 30-60% сокращения токенов по сравнению с JSON для табличных данных. Спецификация определяет модель данных TOON, синтаксис, семантику кодирования/декодирования и требования к соответствию.

## Модель данных

- TOON моделирует данные как:
  - `JsonPrimitive`: строка | число | логическое значение | null
  - `JsonObject`: { [строка]: `JsonValue` }
  - `JsonArray`: `JsonValue`[]
- Порядок сохраняется:
  - Порядок массивов ДОЛЖЕН быть сохранен
  - Порядок ключей объектов ДОЛЖЕН быть сохранен в порядке появления при кодировании

## Нормализация при кодировании

Ссылочный кодировщик нормализует не-JSON значения к модели данных:

- Число:
  - Конечные значения → число (без экспоненциальной записи). -0 → 0
  - NaN, +Infinity, -Infinity → null
- BigInt (JavaScript):
  - Если в пределах Number.MIN_SAFE_INTEGER..Number.MAX_SAFE_INTEGER → преобразуется в число
  - В противном случае → преобразуется в строку с десятичным числом
- Date → ISO строка (например, "2025-01-01T00:00:00.000Z")
- Set → массив путем итерации элементов и нормализации каждого
- Map → объект с использованием String(key) для ключей и нормализацией значений
- Функции, символы, undefined или нераспознанные типы → null

## Синтаксис

### Объекты

- Примитивные поля: `ключ: значение` (один пробел после двоеточия)
- Вложенные или пустые объекты: `ключ:` на отдельной строке. Если не пустой, вложенные поля появляются на глубине +1

### Массивы

#### Примитивные массивы (встроенные)

- Непустые массивы: `ключ[N<разделитель?>]: v1<разделитель>v2<разделитель>…`
- Пустые массивы: `ключ[0<разделитель?>]:` (без значений после двоеточия)

#### Массивы объектов - табличный формат

Табличное обнаружение (кодирование; ДОЛЖНО соблюдаться для всех элементов):
- Каждый элемент является объектом
- Все объекты имеют одинаковый набор ключей (порядок может варьироваться)
- Все значения по этим ключам являются примитивами (без вложенных массивов/объектов)

При соблюдении (кодирование):
- Заголовок: `ключ[N<разделитель?>]{ключ1<разделитель>ключ2<разделитель>…}:`
- Где порядок полей - это порядок появления ключей в первом объекте
- Строки: одна строка на объект на глубине +1 под заголовком; значения кодируются как примитивы (раздел 7) и объединяются через активный разделитель

### Правила кавычек

#### Кодирование строковых значений

Строка ДОЛЖНА быть заключена в кавычки, если выполняется одно из следующих условий:
- Это пустая строка ("")
- Имеет ведущие или конечные пробелы
- Равна true, false или null (с учетом регистра)
- Похожа на числовую:
  - Соответствует /^-?\d+(?:\.\d+)?(?:e[+-]?\d+)?$/i (например, "42", "-3.14", "1e-6")
  - Или соответствует /^0\d+$/ (десятичные числа с ведущими нулями, например "05")
- Содержит двоеточие (:), кавычку (") или обратную косую черту (\)
- Содержит скобки или фигурные скобки ([, ], {, })
- Содержит управляющие символы: новая строка, возврат каретки или табуляция
- Содержит соответствующий разделитель:
  - Внутри области массива: активный разделитель
  - Вне области массива: разделитель документа
- Равна "-" или начинается с "-" (любой дефис в позиции 0)

В противном случае строку МОЖНО выдать без кавычек. Юникод, эмодзи и строки с внутренними (не ведущими/конечными) пробелами безопасны без кавычек при условии, что они не нарушают условий выше.

### Разделители

Поддерживаемые разделители:
- Запятая (по умолчанию): заголовок опускает символ разделителя
- Табуляция: заголовок включает HTAB внутри скобок и фигурных скобок (например, [N<TAB>], {a<TAB>b}); строки/встроенные массивы используют табуляцию
- Пайп: заголовок включает "|" внутри скобок и фигурных скобок; строки/встроенные массивы используют "|"

## Режим строгой проверки

При включенном строгом режиме (по умолчанию) декодеры ДОЛЖНЫ выдавать ошибку в следующих условиях:
- Несоответствие количества и ширины массивов: количество декодированных значений ≠ объявленное N
- Синтаксические ошибки: отсутствующее двоеточие в контексте ключа
- Недопустимые последовательности экранирования или незавершенные строки в кавычках
- Ошибки отступов: ведущие пробелы не кратны размеру отступа
- Пустые строки внутри массивов/табличных строк

## Параметры

### Параметры кодировщика:
- indent (по умолчанию: 2 пробела)
- delimiter (разделитель документа; по умолчанию: запятая; альтернативы: табуляция, пайп)
- lengthMarker (по умолчанию: отключен)

### Параметры декодировщика:
- indent (по умолчанию: 2 пробела)
- strict (по умолчанию: true)

## Примеры

### Объекты:
```
id: 123
name: Ada
active: true
```

### Вложенные объекты:
```
user:
  id: 123
  name: Ada
```

### Примитивные массивы:
```
tags[3]: admin,ops,dev
```

### Табличные массивы:
```
items[2]{sku,qty,price}:
  A1,2,9.99
  B2,1,14.5
```

### Массивы с различными типами:
```
items[3]:
  - 1
  - a: 1
  - text
```

## Безопасность и международизация

- Полную поддержку Unicode можно использовать в ключах и значениях, с учетом правил кавычек и экранирования
- Кодировщики НЕ ДОЛЖНЫ применять локально-зависимое форматирование чисел или логических значений
- Для нормализации дат СЛЕДУЕТ использовать строки ISO 8601

## Связанные темы

[[programming/data_formats/toon_format.md]] - Общее описание формата TOON
[[ai/llm/optimization/toon_for_llm_optimization.md]] - Использование TOON для оптимизации LLM
[[ai/llm/prompt_engineering/prompt_optimization_techniques.md]] - Техники оптимизации промптов
[[programming/data_formats/json_format.md]] - JavaScript Object Notation, формат, с которым сравнивается эффективность TOON